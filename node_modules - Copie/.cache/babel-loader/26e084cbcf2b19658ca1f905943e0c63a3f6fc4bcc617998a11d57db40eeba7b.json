{"ast":null,"code":"import { deepmerge } from 'deepmerge-ts';\nimport { klona } from 'klona/json';\nimport { useRef } from 'react';\nimport { getDark, getPrefix } from '../store/index.js';\nimport { applyPrefix } from './apply-prefix.js';\nimport { applyPrefixV3 } from './apply-prefix-v3.js';\nimport { convertUtilitiesToV4 } from './convert-utilities-to-v4.js';\nimport { deepMergeStrings } from './deep-merge.js';\nimport { getTailwindVersion } from './get-tailwind-version.js';\nimport { isEqual } from './is-equal.js';\nimport { stripDark } from './strip-dark.js';\nimport { twMerge } from './tailwind-merge.js';\nfunction useResolveTheme(...input) {\n  return useStableMemo(() => resolveTheme(...input), input);\n}\nfunction useStableMemo(factory, dependencies) {\n  const prevDepsRef = useRef();\n  const prevResultRef = useRef();\n  const hasChanged = !prevDepsRef.current || !isEqual(prevDepsRef.current, dependencies);\n  if (hasChanged) {\n    prevDepsRef.current = dependencies;\n    prevResultRef.current = factory();\n  }\n  return prevResultRef.current;\n}\nfunction resolveTheme([base, ...custom], clearThemeList, applyThemeList) {\n  const dark = getDark();\n  const prefix = getPrefix();\n  const version = getTailwindVersion();\n  const _custom = custom?.length ? custom?.filter(value => value !== void 0) : void 0;\n  const _clearThemeList = clearThemeList?.length ? clearThemeList?.filter(value => value !== void 0) : void 0;\n  const _applyThemeList = applyThemeList?.length ? applyThemeList?.filter(value => value !== void 0) : void 0;\n  const baseTheme = _clearThemeList?.length || dark === false || version === 4 || prefix ? klona(base) : base;\n  if (_clearThemeList?.length) {\n    const finalClearTheme = cloneWithValue(baseTheme, false);\n    let run = false;\n    for (const clearTheme of _clearThemeList) {\n      if (clearTheme) {\n        run = true;\n      }\n      patchClearTheme(finalClearTheme, clearTheme);\n    }\n    if (run) {\n      runClearTheme(baseTheme, finalClearTheme);\n    }\n  }\n  if (dark === false || version === 4 || prefix) {\n    stringIterator(baseTheme, value => {\n      if (dark === false) {\n        value = stripDark(value);\n      }\n      if (version === 4) {\n        value = convertUtilitiesToV4(value);\n      }\n      if (prefix) {\n        if (version === 3) {\n          value = applyPrefixV3(value, prefix);\n        }\n        if (version === 4) {\n          value = applyPrefix(value, prefix);\n        }\n      }\n      return value;\n    });\n  }\n  let theme = baseTheme;\n  if (_custom?.length) {\n    theme = deepMergeStrings(twMerge)(baseTheme, ..._custom);\n  }\n  if (_applyThemeList?.length && _custom?.length) {\n    const finalApplyTheme = cloneWithValue(baseTheme, \"merge\");\n    let run = false;\n    for (const applyTheme of _applyThemeList) {\n      if (applyTheme !== \"merge\") {\n        run = true;\n      }\n      patchApplyTheme(finalApplyTheme, applyTheme);\n    }\n    if (run) {\n      runApplyTheme(theme, deepmerge(baseTheme, ...custom), finalApplyTheme);\n    }\n  }\n  return theme;\n}\nfunction patchClearTheme(base, clearTheme) {\n  function iterate(base2, clearTheme2) {\n    if (typeof clearTheme2 === \"boolean\") {\n      if (typeof base2 === \"object\" && base2 !== null) {\n        for (const key in base2) {\n          base2[key] = iterate(base2[key], clearTheme2);\n        }\n      } else {\n        return clearTheme2;\n      }\n    }\n    if (typeof clearTheme2 === \"object\" && clearTheme2 !== null) {\n      for (const key in clearTheme2) {\n        base2[key] = iterate(base2[key], clearTheme2[key]);\n      }\n    }\n    return base2;\n  }\n  iterate(base, clearTheme);\n}\nfunction patchApplyTheme(base, applyTheme) {\n  function iterate(base2, applyTheme2) {\n    if (typeof applyTheme2 === \"string\") {\n      if (typeof base2 === \"object\" && base2 !== null) {\n        for (const key in base2) {\n          base2[key] = iterate(base2[key], applyTheme2);\n        }\n      } else {\n        return applyTheme2;\n      }\n    }\n    if (typeof applyTheme2 === \"object\" && applyTheme2 !== null) {\n      for (const key in applyTheme2) {\n        base2[key] = iterate(base2[key], applyTheme2[key]);\n      }\n    }\n    return base2;\n  }\n  iterate(base, applyTheme);\n}\nfunction runClearTheme(base, clearTheme) {\n  function iterate(base2, clearTheme2) {\n    if (clearTheme2 === true) {\n      if (typeof base2 === \"object\" && base2 !== null) {\n        for (const key in base2) {\n          base2[key] = iterate(base2[key], clearTheme2);\n        }\n      } else {\n        return \"\";\n      }\n    }\n    if (typeof clearTheme2 === \"object\" && clearTheme2 !== null) {\n      for (const key in clearTheme2) {\n        base2[key] = iterate(base2[key], clearTheme2[key]);\n      }\n    }\n    return base2;\n  }\n  iterate(base, clearTheme);\n}\nfunction runApplyTheme(base, target, applyTheme) {\n  function iterate(base2, target2, applyTheme2) {\n    if (applyTheme2 === \"replace\") {\n      if (typeof base2 === \"object\" && base2 !== null) {\n        for (const key in base2) {\n          base2[key] = iterate(base2[key], target2[key], applyTheme2);\n        }\n      } else {\n        return target2;\n      }\n    }\n    if (typeof applyTheme2 === \"object\" && applyTheme2 !== null) {\n      for (const key in applyTheme2) {\n        base2[key] = iterate(base2[key], target2[key], applyTheme2[key]);\n      }\n    }\n    return base2;\n  }\n  iterate(base, target, applyTheme);\n}\nfunction stringIterator(input, callback) {\n  function iterate(input2) {\n    if (typeof input2 === \"string\") {\n      return callback(input2);\n    } else if (Array.isArray(input2)) {\n      for (let i = 0; i < input2.length; i++) {\n        input2[i] = iterate(input2[i]);\n      }\n    } else if (typeof input2 === \"object\" && input2 !== null) {\n      for (const key in input2) {\n        input2[key] = iterate(input2[key]);\n      }\n    }\n    return input2;\n  }\n  iterate(input);\n}\nfunction cloneWithValue(input, value) {\n  if (input === null || typeof input !== \"object\") {\n    return value;\n  }\n  const clone = {};\n  for (const key in input) {\n    clone[key] = cloneWithValue(input[key], value);\n  }\n  return clone;\n}\nexport { resolveTheme, useResolveTheme, useStableMemo };","map":{"version":3,"names":["useResolveTheme","input","useStableMemo","resolveTheme","factory","dependencies","prevDepsRef","useRef","prevResultRef","hasChanged","current","isEqual","base","custom","clearThemeList","applyThemeList","dark","getDark","prefix","getPrefix","version","getTailwindVersion","_custom","length","filter","value","_clearThemeList","_applyThemeList","baseTheme","klona","finalClearTheme","cloneWithValue","run","clearTheme","patchClearTheme","runClearTheme","stringIterator","stripDark","convertUtilitiesToV4","applyPrefixV3","applyPrefix","theme","deepMergeStrings","twMerge","finalApplyTheme","applyTheme","patchApplyTheme","runApplyTheme","deepmerge","iterate","base2","clearTheme2","key","applyTheme2","target","target2","callback","input2","Array","isArray","i","clone"],"sources":["C:\\Users\\PC\\mon-projet-react\\node_modules\\flowbite-react\\src\\helpers\\resolve-theme.ts"],"sourcesContent":["import { deepmerge } from \"deepmerge-ts\";\nimport { klona } from \"klona/json\";\nimport { useRef } from \"react\";\nimport { getDark, getPrefix } from \"../store\";\nimport type { ApplyTheme, DeepPartialApplyTheme, DeepPartialBoolean } from \"../types\";\nimport { applyPrefix } from \"./apply-prefix\";\nimport { applyPrefixV3 } from \"./apply-prefix-v3\";\nimport { convertUtilitiesToV4 } from \"./convert-utilities-to-v4\";\nimport { deepMergeStrings } from \"./deep-merge\";\nimport { getTailwindVersion } from \"./get-tailwind-version\";\nimport { isEqual } from \"./is-equal\";\nimport { stripDark } from \"./strip-dark\";\nimport { twMerge } from \"./tailwind-merge\";\n\n/**\n * Memoize wrapper around `resolveTheme` function.\n *\n * @param {...Parameters<typeof resolveTheme>} input - Arguments to pass to `resolveTheme` function\n * @returns {ReturnType<typeof resolveTheme>} The resolved theme configuration\n */\nexport function useResolveTheme<T>(...input: Parameters<typeof resolveTheme<T>>): ReturnType<typeof resolveTheme<T>> {\n  return useStableMemo(() => resolveTheme(...input), input);\n}\n\n/**\n * A custom React hook that memoizes a value similar to `useMemo`, but with stable dependency comparison.\n * This hook ensures that the memoized value only updates when the dependencies have actually changed,\n * using deep equality comparison instead of reference equality.\n *\n * @template T - The type of the memoized value\n * @param {() => T} factory - A function that creates the value to be memoized\n * @param {unknown[]} dependencies - An array of dependencies that determine when the value should be recalculated\n * @returns {T} The memoized value that only changes when dependencies change (using deep equality)\n */\nexport function useStableMemo<T>(factory: () => T, dependencies: unknown[]): T {\n  const prevDepsRef = useRef<unknown[]>();\n  const prevResultRef = useRef<T>();\n\n  const hasChanged = !prevDepsRef.current || !isEqual(prevDepsRef.current, dependencies);\n\n  if (hasChanged) {\n    prevDepsRef.current = dependencies;\n    prevResultRef.current = factory();\n  }\n\n  return prevResultRef.current!;\n}\n\n/**\n * Adds prefix to `base` and merges with custom themes, applying optional `clearTheme` and `applyTheme` modifications.\n *\n * @template T - The type of the base theme.\n * @param {[base, ...custom[]]} themes - An array where the first element is the base theme and the rest are custom themes.\n * @param {DeepPartialBoolean<T>[]} clearThemeList - An array of `clearTheme` modifications to apply to the base theme.\n * @param {DeepPartialApplyTheme<T>[]} applyThemeList - An optional array of `applyTheme` modifications to apply to the merged theme.\n * @returns {T} - The resolved and merged theme.\n */\nexport function resolveTheme<T>(\n  [base, ...custom]: [\n    /** base theme */\n    T,\n    /** custom themes */\n    ...unknown[],\n  ],\n  clearThemeList?: DeepPartialBoolean<T>[],\n  applyThemeList?: DeepPartialApplyTheme<T>[],\n): T {\n  const dark = getDark();\n  const prefix = getPrefix();\n  const version = getTailwindVersion();\n\n  const _custom = custom?.length ? custom?.filter((value) => value !== undefined) : undefined;\n  const _clearThemeList = clearThemeList?.length ? clearThemeList?.filter((value) => value !== undefined) : undefined;\n  const _applyThemeList = applyThemeList?.length ? applyThemeList?.filter((value) => value !== undefined) : undefined;\n\n  const baseTheme = _clearThemeList?.length || dark === false || version === 4 || prefix ? klona(base) : base;\n\n  if (_clearThemeList?.length) {\n    const finalClearTheme = cloneWithValue<T, boolean>(baseTheme, false);\n\n    let run = false;\n\n    for (const clearTheme of _clearThemeList) {\n      if (clearTheme) {\n        run = true;\n      }\n\n      patchClearTheme(finalClearTheme, clearTheme);\n    }\n\n    if (run) {\n      runClearTheme(baseTheme, finalClearTheme as DeepPartialBoolean<T>);\n    }\n  }\n\n  if (dark === false || version === 4 || prefix) {\n    stringIterator(baseTheme, (value) => {\n      if (dark === false) {\n        value = stripDark(value);\n      }\n      if (version === 4) {\n        value = convertUtilitiesToV4(value);\n      }\n      if (prefix) {\n        if (version === 3) {\n          value = applyPrefixV3(value, prefix);\n        }\n        if (version === 4) {\n          value = applyPrefix(value, prefix);\n        }\n      }\n\n      return value;\n    });\n  }\n\n  let theme = baseTheme;\n\n  if (_custom?.length) {\n    theme = deepMergeStrings(twMerge)(baseTheme, ..._custom) as T;\n  }\n\n  if (_applyThemeList?.length && _custom?.length) {\n    const finalApplyTheme = cloneWithValue<T, ApplyTheme>(baseTheme, \"merge\");\n\n    let run = false;\n\n    for (const applyTheme of _applyThemeList) {\n      if (applyTheme !== \"merge\") {\n        run = true;\n      }\n\n      patchApplyTheme(finalApplyTheme, applyTheme);\n    }\n\n    if (run) {\n      runApplyTheme(theme, deepmerge(baseTheme, ...custom) as T, finalApplyTheme as DeepPartialApplyTheme<T>);\n    }\n  }\n\n  return theme;\n}\n\nfunction patchClearTheme<T>(base: T, clearTheme: DeepPartialBoolean<T>): void {\n  function iterate(base: T, clearTheme: DeepPartialBoolean<T>) {\n    if (typeof clearTheme === \"boolean\") {\n      if (typeof base === \"object\" && base !== null) {\n        for (const key in base) {\n          // @ts-expect-error - bypass\n          base[key] = iterate(base[key], clearTheme);\n        }\n      } else {\n        return clearTheme;\n      }\n    }\n    if (typeof clearTheme === \"object\" && clearTheme !== null) {\n      for (const key in clearTheme) {\n        // @ts-expect-error - bypass\n        base[key] = iterate(base[key], clearTheme[key]);\n      }\n    }\n    return base;\n  }\n\n  iterate(base, clearTheme);\n}\n\nfunction patchApplyTheme<T>(base: T, applyTheme: DeepPartialApplyTheme<T>): void {\n  function iterate(base: T, applyTheme: DeepPartialApplyTheme<T>) {\n    if (typeof applyTheme === \"string\") {\n      if (typeof base === \"object\" && base !== null) {\n        for (const key in base) {\n          // @ts-expect-error - bypass\n          base[key] = iterate(base[key], applyTheme);\n        }\n      } else {\n        return applyTheme;\n      }\n    }\n    if (typeof applyTheme === \"object\" && applyTheme !== null) {\n      for (const key in applyTheme) {\n        // @ts-expect-error - bypass\n        base[key] = iterate(base[key], applyTheme[key]);\n      }\n    }\n    return base;\n  }\n\n  iterate(base, applyTheme);\n}\n\n/**\n * Applies `clearTheme` modifications to a base object. If `clearTheme` is `true`,\n * it will recursively set all string properties of the base object to an empty string.\n * If `clearTheme` is an object, it will recursively apply the properties of the `clearTheme`\n * object to the base object.\n *\n * @template T - The type of the base object.\n * @param {T} base - The base object to which `clearTheme` modifications will be applied.\n * @param {DeepPartialBoolean<T>} `clearTheme` - The `clearTheme` modifications to apply. It can be a boolean or an object.\n * @returns {void}\n */\nfunction runClearTheme<T>(base: T, clearTheme: DeepPartialBoolean<T>): void {\n  function iterate(base: T, clearTheme: DeepPartialBoolean<T>) {\n    if (clearTheme === true) {\n      if (typeof base === \"object\" && base !== null) {\n        for (const key in base) {\n          // @ts-expect-error - bypass\n          base[key] = iterate(base[key], clearTheme);\n        }\n      } else {\n        return \"\";\n      }\n    }\n    if (typeof clearTheme === \"object\" && clearTheme !== null) {\n      for (const key in clearTheme) {\n        // @ts-expect-error - bypass\n        base[key] = iterate(base[key], clearTheme[key]);\n      }\n    }\n    return base;\n  }\n\n  iterate(base, clearTheme);\n}\n\n/**\n * Patches and applies a theme by recursively merging or replacing values between base and target objects\n * based on the `applyTheme` configuration.\n *\n * @template T - The type of the theme object\n * @param {T} base - The base theme object to be modified\n * @param {T} target - The target theme object containing new values\n * @param {DeepPartialApplyTheme<T>} applyTheme - Configuration object that determines how the theme should be applied\n * @returns {void}\n */\nfunction runApplyTheme<T>(base: T, target: T, applyTheme: DeepPartialApplyTheme<T>): void {\n  function iterate(base: T, target: T, applyTheme: DeepPartialApplyTheme<T>) {\n    if (applyTheme === \"replace\") {\n      if (typeof base === \"object\" && base !== null) {\n        for (const key in base) {\n          // @ts-expect-error - bypass\n          base[key] = iterate(base[key], target[key], applyTheme);\n        }\n      } else {\n        return target;\n      }\n    }\n    if (typeof applyTheme === \"object\" && applyTheme !== null) {\n      for (const key in applyTheme) {\n        // @ts-expect-error - bypass\n        base[key] = iterate(base[key], target[key], applyTheme[key]);\n      }\n    }\n    return base;\n  }\n\n  iterate(base, target, applyTheme);\n}\n\n/**\n * Iterates over a given input and applies a callback function to each string value found.\n * The input can be a string, an array, or an object containing strings.\n *\n * @template T - The type of the input.\n * @param {T} input - The input to iterate over. It can be a string, an array, or an object.\n * @param {(value: string) => string} callback - The callback function to apply to each string value.\n * @returns {void}\n */\nfunction stringIterator<T>(input: T, callback: (value: string) => string): void {\n  function iterate(input: T) {\n    if (typeof input === \"string\") {\n      return callback(input);\n    } else if (Array.isArray(input)) {\n      for (let i = 0; i < input.length; i++) {\n        input[i] = iterate(input[i]);\n      }\n    } else if (typeof input === \"object\" && input !== null) {\n      for (const key in input) {\n        // @ts-expect-error - bypass\n        input[key] = iterate(input[key]);\n      }\n    }\n    return input;\n  }\n\n  iterate(input);\n}\n\n/**\n * Creates a deep clone of an object structure with all leaf values replaced by a specified value.\n *\n * @template T - The type of the input object\n * @template V - The type of the value to replace with\n * @param {T} input - The input object to clone\n * @param {V} value - The value to replace all leaf values with\n * @returns {T} A new object with the same structure as input but all leaf values replaced with the specified value\n *\n * @example\n * const obj = { a: 1, b: { c: 2 } };\n * const result = cloneWithValue(obj, 'new');\n * // result = { a: 'new', b: { c: 'new' } }\n */\nfunction cloneWithValue<T, V>(input: T, value: V): T {\n  if (input === null || typeof input !== \"object\") {\n    return value as unknown as T;\n  }\n\n  const clone = {} as T;\n\n  for (const key in input) {\n    clone[key as keyof T] = cloneWithValue(input[key as keyof T], value);\n  }\n\n  return clone;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}